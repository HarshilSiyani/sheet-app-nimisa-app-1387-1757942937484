# Google Sheets API Configuration
VITE_GOOGLE_SHEETS_API_KEY=sk_c8a2ee34aa1b4f579496b453d412bbd1
VITE_SPREADSHEET_ID=1TkIgTxvyrDJNvvo_jBOaWxleHFpJd_8yjjrytw__XqA

# App Configuration
VITE_APP_NAME=Nimisa App
VITE_APP_DESCRIPTION=Manage and track Nimisa data with real-time Google Sheets integration

# Optional: Custom prompt for AI generation
VITE_CUSTOM_PROMPT=Build a React app for the Google Sheet: "Nimisa"

SHEET STRUCTURE:
- Headers: PatientName, Number, Visited, AppointedStaff
- Total rows: 9
- Columns: 4

SAMPLE DATA (first 5 rows):
1. PatientName: "John" | Number: "123" | Visited: "No" | AppointedStaff: "Nimisha"
2. PatientName: "Smith" | Number: "234" | Visited: "Yes" | AppointedStaff: "Tom"
3. PatientName: "Nim" | Number: "343" | Visited: "Yes" | AppointedStaff: "Gor"
4. PatientName: "TestClaude" | Number: "111" | Visited: "No" | AppointedStaff: "harshil"
5. PatientName: "TestClaude" | Number: "111" | Visited: "No" | AppointedStaff: "harshil"

SHEETCLIENT API DOCUMENTATION:
The SheetClient must be instantiated before use: `const client = new SheetClient();`

AVAILABLE METHODS:

1. **getAllData()**
   - Input: None
   - Output: Promise<SheetRow[]> - Returns array of row objects with named properties
   - Example: `const data = await client.getAllData();`
   - Returns: `[{ PatientName: "value", Number: "value", Visited: "value", AppointedStaff: "value", _id: "...", _rowIndex: 1 }, ...]`

2. **addRow(data)**
   - Input: Record<string, any> - Object with field names as keys
   - Output: Promise<ApiResponse> - Returns {success: boolean, error?: string}
   - Example: `await client.addRow({PatientName: "value", Number: "value", Visited: "value", AppointedStaff: "value"})`

3. **updateField(params)**
   - Input: UpdateOperation object {identifier, field, newValue, oldValue?}
   - Output: Promise<ApiResponse> - Returns {success: boolean, error?: string}
   - Example: `await client.updateField({identifier: "John", field: "Visited", newValue: "Yes"})`

4. **search(query)**
   - Input: SearchQuery object {field?, value?, operator?}
   - Output: Promise<SheetRow[]> - Returns matching row objects
   - Example: `await client.search({value: "search term", operator: "contains"})`

5. **getRowById(identifier)**
   - Input: string | number - Row identifier
   - Output: Promise<SheetRow | null> - Returns single row object or null
   - Example: `await client.getRowById("identifier")`

IMPORTANT API CONSTRAINTS:
- DELETE operations are NOT available - rows cannot be deleted via API
- UPDATE operations work on individual fields, not entire rows
- All methods return objects with named properties, NOT arrays
- Must instantiate SheetClient: `const client = new SheetClient()`
- API responses use {success: boolean, error?: string} format
- Row objects include _id and _rowIndex metadata fields

EFFICIENT API USAGE (RATE LIMIT CONSIDERATIONS):
- Call getAllData() once on component mount and cache results
- Use local state updates for immediate UI feedback
- Only call API methods for actual persistence
- Implement optimistic updates where possible
- Use the built-in 30-second cache in SheetClient
- Batch multiple operations when possible

DATA STRUCTURE:
```typescript
interface SheetRow {
  PatientName: string;
  Number: string;
  Visited: string;
  AppointedStaff: string;
  _id: string;
  _rowIndex: number;
}

interface ApiResponse {
  success: boolean;
  error?: string;
}
```

USAGE NOTES:
- Always handle async operations with try/catch blocks
- The SheetClient automatically handles authentication and sheet connection
- All methods return Promises - use await or .then()
- Data is returned as objects with named properties for easy access
- Handle ApiResponse.success to check operation results

AVAILABLE DEPENDENCIES:
- react, { useState, useEffect }
- lucide-react (for icons: Search, Plus, Edit, Trash2, Save, X, etc.)
- SheetClient from './api/client' (pre-configured, must be instantiated)

REQUIREMENTS:
- Create a modern, responsive UI using the CORRECT SheetClient API
- Handle the fact that delete operations are not available
- Use proper object destructuring for row data
- Implement proper error handling for API responses
- Show user-friendly messages when operations succeed/fail
- Use Tailwind CSS for clean, professional styling
- Include proper loading states and error handling
- Add data visualization if appropriate for the data type
- IMPORTANT: Only modify App.tsx, do not change any API configuration files
- The SheetClient API is pre-configured and requires instantiation

TECHNICAL REQUIREMENTS:
- Use TypeScript with proper interfaces
- Implement proper error boundaries
- Add form validation for user inputs
- Include success/error notifications
- Make it mobile responsive with mobile-first design
- Add loading spinners during API calls
- Use React hooks (useState, useEffect) for state management

MOBILE & VISUAL REQUIREMENTS:
- Design for mobile app format - touch-friendly buttons, proper spacing
- Add charts and visualizations where appropriate using simple CSS/SVG or canvas
- Include summary cards with key metrics
- Use responsive grid layouts that work on phones
- Add smooth animations and transitions
- Include data visualization charts (bar charts, pie charts, progress indicators)
- Make buttons large enough for mobile touch (min 44px height)
- Use mobile-optimized forms with proper input types

Add charts and visuals where possible and make sure it's usable in mobile app format with touch-friendly interface.

Make the interface intuitive and user-friendly for managing this specific type of data with beautiful visualizations and mobile-optimized design.
